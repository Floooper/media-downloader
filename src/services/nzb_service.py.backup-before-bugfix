import asyncio
import pynzb
import aionntpclib
import yenc
import os
import hashlib
import logging
import par2
import time
from typing import Optional, Dict, List, Tuple, Set
from dataclasses import dataclass
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from asyncio import Queue, Lock

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class NZBSegment:
    number: int
    bytes: int
    message_id: str
    crc32: Optional[str] = None
    part: int = 1
    total_parts: int = 1
    downloaded: bool = False
    data: Optional[bytes] = None
    retries: int = 0
    last_error: Optional[str] = None

@dataclass 
class NZBFile:
    subject: str
    groups: List[str]
    segments: List[NZBSegment]
    total_bytes: int = 0
    downloaded_bytes: int = 0
    priority: int = 0
    paused: bool = False
    verified: bool = False
    repair_needed: bool = False

class NZBDownloader:
    def __init__(self, usenet_server: str, port: int, use_ssl: bool, username: str, password: str, 
                 max_connections: int = 10, retention_days: int = 1500, 
                 download_rate_limit: Optional[int] = None,
                 max_retries: int = 3):
        self.server = usenet_server
        self.port = port
        self.use_ssl = use_ssl
        self.username = username
        self.password = password
        self.max_connections = max_connections
        self.retention_days = retention_days
        self.download_rate_limit = download_rate_limit
        self.max_retries = max_retries
        self.active_downloads: Dict[str, Dict] = {}
        self.connections: List[aionntpclib.Client] = []
        self.connection_locks: Dict[aionntpclib.Client, Lock] = {}
        self.rate_limiter = asyncio.Lock()
        self.last_download_time = 0
        self.bytes_downloaded_window: List[Tuple[float, int]] = []
        self.connection_pool: Queue[aionntpclib.Client] = Queue()
        self.failed_connections: Set[aionntpclib.Client] = set()

    async def _create_nntp_connection(self) -> aionntpclib.Client:
        client = aionntpclib.Client(
            hostname=self.server,
            port=self.port,
            ssl=self.use_ssl
        )
        await client.connect()
        await client.login(self.username, self.password)
        return client

    async def initialize_connections(self):
        """Create and initialize the connection pool"""
        for _ in range(self.max_connections):
            try:
                conn = await self._create_nntp_connection()
                self.connections.append(conn)
                self.connection_locks[conn] = Lock()
                await self.connection_pool.put(conn)
            except Exception as e:
                logger.error(f"Failed to create NNTP connection: {str(e)}")
                
    async def _recycle_connection(self, conn: aionntpclib.Client):
        """Recycle a potentially problematic connection"""
        try:
            self.failed_connections.add(conn)
            await conn.quit()
        except:
            pass
            
        try:
            new_conn = await self._create_nntp_connection()
            self.connections.append(new_conn)
            self.connection_locks[new_conn] = Lock()
            await self.connection_pool.put(new_conn)
            self.failed_connections.remove(conn)
            self.connections.remove(conn)
            del self.connection_locks[conn]
        except Exception as e:
            logger.error(f"Failed to recycle connection: {str(e)}")

    async def get_connection(self) -> aionntpclib.Client:
        """Get an available connection from the pool with rate limiting"""
        while True:
            conn = await self.connection_pool.get()
            
            if conn in self.failed_connections:
                continue
                
            async with self.connection_locks[conn]:
                # Apply rate limiting if configured
                if self.download_rate_limit:
                    current_time = time.time()
                    window_start = current_time - 1.0  # 1 second window
                    
                    # Clean old entries
                    self.bytes_downloaded_window = [
                        (t, b) for t, b in self.bytes_downloaded_window
                        if t > window_start
                    ]
                    
                    # Calculate current rate
                    current_rate = sum(b for _, b in self.bytes_downloaded_window)
                    
                    if current_rate >= self.download_rate_limit:
                        await asyncio.sleep(0.1)
                        await self.connection_pool.put(conn)
                        continue
                        
                return conn

    async def process_nzb_file(self, nzb_content: bytes, save_path: str) -> str:
        nzb_data = pynzb.parse(nzb_content)
        download_id = str(datetime.now().timestamp())
        
        self.active_downloads[download_id] = {
            'files': [],
            'total_bytes': 0,
            'downloaded_bytes': 0,
            'save_path': save_path,
            'status': 'preparing'
        }

        for nzb_file in nzb_data:
            segments = []
            total_bytes = 0

            # Parse yEnc headers from subject if present
            subject = nzb_file.subject
            if '[' in subject and ']' in subject:
                yenc_info = subject[subject.find('[')+1:subject.find(']')]
                if 'yEnc' in yenc_info:
                    parts = [p.strip() for p in yenc_info.split(' ') if '/' in p]
                    if parts:
                        part, total = map(int, parts[0].split('/'))
                    else:
                        part, total = 1, 1
                else:
                    part, total = 1, 1
            else:
                part, total = 1, 1

            for segment in sorted(nzb_file.segments, key=lambda x: x.number):
                segments.append(NZBSegment(
                    number=segment.number,
                    bytes=segment.bytes,
                    message_id=segment.message_id,
                    part=part,
                    total_parts=total
                ))
                total_bytes += segment.bytes

            nzb_file_obj = NZBFile(
                subject=nzb_file.subject,
                groups=nzb_file.groups,
                segments=segments,
                total_bytes=total_bytes
            )
            
            self.active_downloads[download_id]['files'].append(nzb_file_obj)
            self.active_downloads[download_id]['total_bytes'] += total_bytes
        
        return download_id

    async def download_segment(self, segment: NZBSegment, group: str, download_id: str) -> Tuple[bytes, bool]:
        connection = await self.get_connection()
        try:
            # Select newsgroup
            await connection.group(group)
            
            # Get article by message ID
            _, response = await connection.article(segment.message_id)
            
            # Find and decode yEnc data
            yenc_data = None
            for line in response.lines:
                line = line.strip()
                if line.startswith(b'=ybegin'):
                    # Found start of yEnc data
                    yenc_data = []
                elif yenc_data is not None:
                    if line.startswith(b'=yend'):
                        break
                    yenc_data.append(line)
            
            if not yenc_data:
                raise Exception("No yEnc data found in article")
                
            # Decode yEnc data
            decoder = yenc.Decoder()
            for line in yenc_data:
                decoder.feed(line)
            decoded_data = decoder.getDecoded()
            
            # Verify CRC32 if available
            if segment.crc32:
                computed_crc = format(hashlib.crc32(decoded_data) & 0xFFFFFFFF, '08x')
                if computed_crc.lower() != segment.crc32.lower():
                    return decoded_data, False
                    
            # Update rate limiting data if enabled
            if self.download_rate_limit:
                current_time = time.time()
                self.bytes_downloaded_window.append((current_time, len(decoded_data)))
            
            return decoded_data, True
            
        except Exception as e:
            segment.retries += 1
            segment.last_error = str(e)
            logger.error(f"Error downloading segment {segment.number} for {download_id}: {str(e)}")
            
            if isinstance(e, (aionntpclib.NNTPError, ConnectionError)):
                await self._recycle_connection(connection)
                
            return None, False
        finally:
            if connection not in self.failed_connections:
                await self.connection_pool.put(connection)

    async def verify_and_repair(self, download_id: str, nzb_file: NZBFile):
        """Verify and repair downloaded files using par2"""
        download = self.active_downloads[download_id]
        download_path = download['save_path']
        
        try:
            # Find par2 files
            par2_files = [f for f in os.listdir(download_path) if f.endswith('.par2')]
            if not par2_files:
                logger.info(f"No par2 files found for {nzb_file.subject}")
                return True
                
            # Initialize par2 client
            p = par2.Par2Client()
            main_par2 = os.path.join(download_path, par2_files[0])
            p.load(main_par2)
            
            # Verify files
            if not p.verify():
                logger.warning(f"Verification failed for {nzb_file.subject}, attempting repair")
                nzb_file.repair_needed = True
                
                # Attempt repair
                if p.repair():
                    logger.info(f"Successfully repaired {nzb_file.subject}")
                    nzb_file.verified = True
                    return True
                else:
                    logger.error(f"Failed to repair {nzb_file.subject}")
                    return False
            else:
                logger.info(f"Verification successful for {nzb_file.subject}")
                nzb_file.verified = True
                return True
                
        except Exception as e:
            logger.error(f"Error during par2 verification: {str(e)}")
            return False
            
    async def _download_file(self, download_id: str, nzb_file: NZBFile):
        """Download a single NZB file with its segments"""
        download = self.active_downloads[download_id]
        file_data = bytearray()
        retry_segments = []

        # Create segments download tasks
        tasks = []
        for segment in nzb_file.segments:
            for group in nzb_file.groups:
                if segment.retries < self.max_retries:
                    task = asyncio.create_task(self.download_segment(segment, group, download_id))
                    tasks.append((segment, task))

        # Wait for all segments
        for segment, task in tasks:
            try:
                data, success = await task
                if success and data:
                    segment.data = data
                    segment.downloaded = True
                    nzb_file.downloaded_bytes += len(data)
                    download['downloaded_bytes'] += len(data)
                else:
                    retry_segments.append(segment)
            except Exception as e:
                print(f"Error downloading segment {segment.number}: {str(e)}")
                retry_segments.append(segment)

        # Retry failed segments
        if retry_segments:
            print(f"Retrying {len(retry_segments)} failed segments...")
            for segment in retry_segments:
                for group in nzb_file.groups:
                    try:
                        data, success = await self.download_segment(segment, group)
                        if success and data:
                            segment.data = data
                            segment.downloaded = True
                            nzb_file.downloaded_bytes += len(data)
                            download['downloaded_bytes'] += len(data)
                            break
                    except Exception as e:
                        print(f"Retry failed for segment {segment.number}: {str(e)}")

        # Assemble file from segments
        segments = sorted(nzb_file.segments, key=lambda x: x.number)
        for segment in segments:
            if segment.downloaded and segment.data:
                file_data.extend(segment.data)
                segment.data = None  # Free memory

        # Save completed file
        if file_data:
            filename = os.path.basename(nzb_file.subject)
            if '[' in filename and ']' in filename:
                filename = filename[filename.rfind(']')+1:].strip()
            file_path = os.path.join(download['save_path'], filename)
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            with open(file_path, 'wb') as f:
                f.write(file_data)

    async def start_download(self, download_id: str):
        """Start downloading all files in the NZB"""
        if download_id not in self.active_downloads:
            raise Exception("Download not found")

        download = self.active_downloads[download_id]
        download['status'] = 'downloading'

        try:
            # Initialize connection pool if needed
            if not self.connections:
                await self.initialize_connections()

            # Download files in parallel
            tasks = []
            for nzb_file in download['files']:
                task = asyncio.create_task(self._download_file(download_id, nzb_file))
                tasks.append(task)

            await asyncio.gather(*tasks)
            
            # Verify and repair files if needed
            if await self.verify_and_repair(download_id, nzb_file):
                download['status'] = 'completed'
            else:
                download['status'] = 'verification_failed'

        except Exception as e:
            download['status'] = 'failed'
            raise e

    def get_progress(self, download_id: str) -> Optional[float]:
        """Get download progress percentage"""
        if download_id not in self.active_downloads:
            return None
            
        download = self.active_downloads[download_id]
        if download['total_bytes'] == 0:
            return 0.0
            
        return (download['downloaded_bytes'] / download['total_bytes']) * 100

    def get_status(self, download_id: str) -> Optional[Dict]:
        """Get detailed download status"""
        if download_id not in self.active_downloads:
            return None
            
        download = self.active_downloads[download_id]
        return {
            'status': download['status'],
            'progress': self.get_progress(download_id),
            'downloaded_bytes': download['downloaded_bytes'],
            'total_bytes': download['total_bytes'],
            'files': [{
                'subject': f.subject,
                'downloaded_bytes': f.downloaded_bytes,
                'total_bytes': f.total_bytes,
                'progress': (f.downloaded_bytes / f.total_bytes * 100) if f.total_bytes > 0 else 0,
                'verified': f.verified,
                'repair_needed': f.repair_needed,
                'paused': f.paused
            } for f in download['files']],
            'failed_segments': sum(1 for f in download['files'] 
                                 for s in f.segments 
                                 if not s.downloaded and s.retries >= self.max_retries)
        }
        
    async def pause_download(self, download_id: str):
        """Pause a download"""
        if download_id in self.active_downloads:
            download = self.active_downloads[download_id]
            for nzb_file in download['files']:
                nzb_file.paused = True
            download['status'] = 'paused'
            
    async def resume_download(self, download_id: str):
        """Resume a paused download"""
        if download_id in self.active_downloads:
            download = self.active_downloads[download_id]
            for nzb_file in download['files']:
                nzb_file.paused = False
            if download['status'] == 'paused':
                download['status'] = 'downloading'
                await self.start_download(download_id)
                
    async def set_priority(self, download_id: str, priority: int):
        """Set download priority"""
        if download_id in self.active_downloads:
            download = self.active_downloads[download_id]
            for nzb_file in download['files']:
                nzb_file.priority = priority

