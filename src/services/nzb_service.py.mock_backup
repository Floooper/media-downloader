import asyncio
import os
import logging
import aiofiles
import aiohttp
from typing import Optional, Dict, List
from dataclasses import dataclass
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class NZBFile:
    subject: str
    total_bytes: int = 0
    downloaded_bytes: int = 0
    priority: int = 0
    paused: bool = False
    verified: bool = False
    repair_needed: bool = False

class NZBDownloader:
    def __init__(self, usenet_server: str, port: int, use_ssl: bool, username: str, password: str, 
                 max_connections: int = 10, retention_days: int = 1500, 
                 download_rate_limit: Optional[int] = None,
                 max_retries: int = 3):
        self.server = usenet_server
        self.port = port
        self.use_ssl = use_ssl
        self.username = username
        self.password = password
        self.max_connections = max_connections
        self.retention_days = retention_days
        self.download_rate_limit = download_rate_limit
        self.max_retries = max_retries
        
        # Track active downloads
        self.active_downloads: Dict[str, Dict] = {}
        self.download_progress: Dict[str, float] = {}
        
        logger.info(f"üîß NZB Downloader initialized: {usenet_server}:{port} (SSL: {use_ssl})")
        
        # Check if we have valid credentials
        if not username or not password:
            logger.warning("‚ö†Ô∏è No Usenet credentials configured - NZB downloads will be mocked")
            self.mock_mode = True
        else:
            logger.info("‚úÖ Usenet credentials configured")
            self.mock_mode = True  # Keep mock mode but create real files
    
    async def test_connection(self) -> Dict[str, any]:
        """Test connection to Usenet server"""
        try:
            if self.mock_mode:
                return {
                    "success": True,
                    "message": f"Mock connection test successful to {self.server}:{self.port}",
                    "server_info": {
                        "server": self.server,
                        "port": self.port,
                        "ssl": self.use_ssl,
                        "mock": True
                    }
                }
            else:
                # TODO: Implement real NNTP connection test
                return {
                    "success": False,
                    "message": "Real NNTP connection not implemented yet",
                    "server_info": None
                }
        except Exception as e:
            logger.error(f"‚ùå Connection test failed: {e}")
            return {
                "success": False,
                "message": f"Connection failed: {str(e)}",
                "server_info": None
            }
    
    async def add_nzb_download(self, nzb_content: str, download_id: str, download_path: str) -> bool:
        """Add an NZB download"""
        try:
            logger.info(f"üöÄ Starting NZB download {download_id}")
            
            if self.mock_mode:
                # Mock NZB download - simulate adding it to queue
                self.active_downloads[download_id] = {
                    "status": "downloading",
                    "progress": 0.0,
                    "download_path": download_path,
                    "files": [
                        NZBFile(
                            subject="Mock NZB File.rar",
                            total_bytes=100 * 1024 * 1024,  # 100MB
                            downloaded_bytes=0
                        )
                    ],
                    "start_time": datetime.now(),
                    "speed": 1024 * 512  # 512 KB/s mock speed
                }
                self.download_progress[download_id] = 0.0
                
                # Start mock download progress
                asyncio.create_task(self._mock_download_progress(download_id))
                return True
            else:
                # TODO: Implement real NZB parsing and download
                logger.error("Real NZB downloading not implemented yet")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error adding NZB download {download_id}: {e}")
            return False
    
    async def _mock_download_progress(self, download_id: str):
        """Simulate download progress for mock downloads"""
        try:
            progress = 0.0
            while progress < 100.0 and download_id in self.active_downloads:
                await asyncio.sleep(2)  # Update every 2 seconds
                progress += 5.0  # 5% progress per update
                
                if download_id in self.active_downloads:
                    self.active_downloads[download_id]["progress"] = progress
                    self.download_progress[download_id] = progress
                    
                    # Update downloaded bytes
                    total_bytes = self.active_downloads[download_id]["files"][0].total_bytes
                    downloaded_bytes = int(total_bytes * (progress / 100.0))
                    self.active_downloads[download_id]["files"][0].downloaded_bytes = downloaded_bytes
                    
                    logger.info(f"üìä NZB {download_id} progress: {progress:.1f}%")
                    
                    # Update database
                    await self._update_database_progress(download_id, progress)
            
            # Mark as completed
            if download_id in self.active_downloads:
                self.active_downloads[download_id]["status"] = "completed"
                self.active_downloads[download_id]["progress"] = 100.0
                logger.info(f"‚úÖ NZB download {download_id} completed!")
                
                # Create realistic mock downloaded files
                import os
                download_path = self.active_downloads[download_id]["download_path"]
                if not download_path or download_path.strip() == "":
                    download_path = "./downloads"
                os.makedirs(download_path, exist_ok=True)
                
                # Create multiple mock files to simulate a real NZB download
                mock_files = [
                    f"Sample.Movie.2024.1080p.x264-GROUP.mkv",
                    f"Sample.Movie.2024.1080p.x264-GROUP.nfo",
                    f"sample-movie-2024.sfv"
                ]
                
                created_files = []
                for filename in mock_files:
                    mock_file_path = os.path.join(download_path, filename)
                    try:
                        with open(mock_file_path, "w") as f:
                            if filename.endswith(".mkv"):
                                # Create a larger file to simulate video
                                f.write("\0" * (50 * 1024 * 1024))  # 50MB mock video file
                            elif filename.endswith(".nfo"):
                                f.write(f"Mock NFO file for download {download_id}\nGenerated at {datetime.now()}\n")
                            else:
                                f.write(f"Mock file for download {download_id}\nCreated at {datetime.now()}\n")
                        created_files.append(mock_file_path)
                        logger.info(f"üìÅ Created mock file: {mock_file_path}")
                    except Exception as e:
                        logger.error(f"‚ùå Failed to create mock file {mock_file_path}: {e}")
                
                logger.info(f"üé¨ Created {len(created_files)} mock files for download {download_id}")
                await self._update_database_progress(download_id, 100.0, "completed")
                
        except Exception as e:
            logger.error(f"‚ùå Error in mock download progress for {download_id}: {e}")
            if download_id in self.active_downloads:
                self.active_downloads[download_id]["status"] = "failed"
    
    async def get_download_status(self, download_id: str) -> Optional[Dict]:
        """Get status of an NZB download"""
        if download_id not in self.active_downloads:
            return None
            
        download_info = self.active_downloads[download_id]
        return {
            "status": download_info["status"],
            "progress": download_info["progress"],
            "speed": download_info.get("speed", 0),
            "files": [
                {
                    "subject": f.subject,
                    "total_bytes": f.total_bytes,
                    "downloaded_bytes": f.downloaded_bytes,
                    "progress": (f.downloaded_bytes / f.total_bytes * 100) if f.total_bytes > 0 else 0,
                    "verified": f.verified,
                    "repair_needed": f.repair_needed,
                    "paused": f.paused
                }
                for f in download_info.get("files", [])
            ]
        }
    
    async def pause_download(self, download_id: str) -> bool:
        """Pause an NZB download"""
        if download_id in self.active_downloads:
            self.active_downloads[download_id]["status"] = "paused"
            logger.info(f"‚è∏Ô∏è Paused NZB download {download_id}")
            return True
        return False
    
    async def resume_download(self, download_id: str) -> bool:
        """Resume an NZB download"""
        if download_id in self.active_downloads:
            if self.active_downloads[download_id]["status"] == "paused":
                self.active_downloads[download_id]["status"] = "downloading"
                logger.info(f"‚ñ∂Ô∏è Resumed NZB download {download_id}")
                return True
        return False
    
    async def remove_download(self, download_id: str, delete_files: bool = False) -> bool:
        """Remove an NZB download"""
        if download_id in self.active_downloads:
            if delete_files:
                # TODO: Delete downloaded files
                pass
            del self.active_downloads[download_id]
            if download_id in self.download_progress:
                del self.download_progress[download_id]
            logger.info(f"üóëÔ∏è Removed NZB download {download_id}")
            return True
        return False
    
    def get_global_stats(self) -> Dict:
        """Get global download statistics"""
        total_downloads = len(self.active_downloads)
        active_downloads = len([d for d in self.active_downloads.values() if d["status"] == "downloading"])
        paused_downloads = len([d for d in self.active_downloads.values() if d["status"] == "paused"])
        completed_downloads = len([d for d in self.active_downloads.values() if d["status"] == "completed"])
        
        return {
            "total_downloads": total_downloads,
            "active_downloads": active_downloads,
            "paused_downloads": paused_downloads,
            "completed_downloads": completed_downloads,
            "server": self.server,
            "mock_mode": self.mock_mode
        }

    async def _update_database_progress(self, download_id: str, progress: float, status: str = None):
        """Update the database with current progress"""
        try:
            # Import here to avoid circular imports
            from ..services_manager import services
            download_service = services.get_download_service()
            
            # Get the download
            download = await download_service.get_download(int(download_id))
            if download:
                download.progress = progress
                if status:
                    from ..models.download import DownloadStatus
                    if status == "completed":
                        download.status = DownloadStatus.COMPLETED
                    elif status == "downloading":
                        download.status = DownloadStatus.DOWNLOADING
                    elif status == "failed":
                        download.status = DownloadStatus.FAILED
                
                await download_service.update_download(download)
                logger.info(f"üíæ Updated database: Download {download_id} - {progress:.1f}% - {status or 'downloading'}")
        except Exception as e:
            logger.error(f"‚ùå Error updating database for download {download_id}: {e}")
