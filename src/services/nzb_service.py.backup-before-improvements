import asyncio
import os
import logging
import aiofiles
import nntplib
import ssl
import tempfile
import xml.etree.ElementTree as ET
from typing import Optional, Dict, List, Tuple
from dataclasses import dataclass
from datetime import datetime
import threading
import queue
import time
import re

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

try:
    import pynzb
    HAS_PYNZB = True
    logger.info("‚úÖ pynzb available for NZB parsing")
except ImportError:
    HAS_PYNZB = False
    logger.warning("‚ö†Ô∏è pynzb not available - NZB parsing will be limited")

try:
    import sabyenc3 as yenc
    HAS_YENC = True
    logger.info("‚úÖ sabyenc3 available for yEnc decoding")
except ImportError:
    try:
        import yenc
        HAS_YENC = True
        logger.info("‚úÖ yenc available for yEnc decoding")
    except ImportError:
        HAS_YENC = False
        logger.warning("‚ö†Ô∏è yenc not available - will use manual decoding")

@dataclass
class NZBFile:
    subject: str
    groups: List[str]
    segments: List[Dict]
    total_bytes: int = 0
    downloaded_bytes: int = 0
    priority: int = 0
    paused: bool = False
    verified: bool = False
    repair_needed: bool = False

@dataclass
class NZBSegment:
    message_id: str
    number: int
    bytes: int
    
class NZBDownloader:
    def __init__(self, usenet_server: str, port: int, use_ssl: bool, username: str, password: str, 
                 max_connections: int = 10, retention_days: int = 1500, 
                 download_rate_limit: Optional[int] = None,
                 max_retries: int = 3):
        self.server = usenet_server
        self.port = port
        self.use_ssl = use_ssl
        self.username = username
        self.password = password
        self.max_connections = max_connections
        self.retention_days = retention_days
        self.download_rate_limit = download_rate_limit
        self.max_retries = max_retries
        
        # Track active downloads
        self.active_downloads: Dict[str, Dict] = {}
        self.download_progress: Dict[str, float] = {}
        self.download_threads: Dict[str, threading.Thread] = {}
        
        logger.info(f"üîß NZB Downloader initialized: {usenet_server}:{port} (SSL: {use_ssl})")
        
        # Check if we have valid credentials and enable real mode
        if not username or not password or username == 'test' or password == 'test':
            logger.warning("‚ö†Ô∏è No valid Usenet credentials configured - NZB downloads will be mocked")
            self.mock_mode = True
        else:
            logger.info("‚úÖ Usenet credentials configured - Real downloads enabled")
            self.mock_mode = False
    
    def _create_nntp_connection(self) -> nntplib.NNTP:
        """Create an NNTP connection"""
        try:
            if self.use_ssl:
                context = ssl.create_default_context()
                server = nntplib.NNTP_SSL(self.server, self.port, ssl_context=context)
            else:
                server = nntplib.NNTP(self.server, self.port)
            
            # Authenticate
            server.login(self.username, self.password)
            logger.info(f"‚úÖ Connected to {self.server}:{self.port}")
            return server
        except Exception as e:
            logger.error(f"‚ùå Failed to connect to NNTP server: {e}")
            raise
    
    async def test_connection(self) -> Dict[str, any]:
        """Test connection to Usenet server"""
        try:
            if self.mock_mode:
                return {
                    "success": True,
                    "message": f"Mock connection test successful to {self.server}:{self.port}",
                    "server_info": {
                        "server": self.server,
                        "port": self.port,
                        "ssl": self.use_ssl,
                        "mock": True
                    }
                }
            else:
                # Test real NNTP connection
                def test_conn():
                    server = self._create_nntp_connection()
                    info = server.help()
                    server.quit()
                    return info
                
                # Run in thread to avoid blocking
                loop = asyncio.get_event_loop()
                info = await loop.run_in_executor(None, test_conn)
                
                return {
                    "success": True,
                    "message": f"Successfully connected to {self.server}:{self.port}",
                    "server_info": {
                        "server": self.server,
                        "port": self.port,
                        "ssl": self.use_ssl,
                        "mock": False,
                        "server_info": str(info)[:200] + "..." if len(str(info)) > 200 else str(info)
                    }
                }
        except Exception as e:
            logger.error(f"‚ùå Connection test failed: {e}")
            return {
                "success": False,
                "message": f"Connection failed: {str(e)}",
                "server_info": None
            }
    
    def _extract_filename_from_subject(self, subject: str) -> str:
        """Extract a clean filename from NZB subject line"""
        try:
            # Common patterns in NZB subjects
            # Example: [12345] "Movie.Name.2024.1080p.BluRay.x264-GROUP" yEnc (001/145)
            # Example: Movie.Name.2024.1080p.BluRay.x264-GROUP.mkv
            
            # Remove common prefixes like [numbers] and quotes
            cleaned = re.sub(r'^\[[\d\w\-\+]+\]\s*', '', subject)
            cleaned = re.sub(r'^"([^"]+)".*', r'\1', cleaned)
            
            # Remove yEnc and part information
            cleaned = re.sub(r'\s+yEnc.*$', '', cleaned)
            cleaned = re.sub(r'\s+\(\d+/\d+\).*$', '', cleaned)
            
            # Clean up extra spaces and special characters
            cleaned = re.sub(r'\s+', ' ', cleaned).strip()
            
            # If we still have something reasonable, use it
            if len(cleaned) > 3 and not cleaned.isdigit():
                return cleaned
            
            # Fallback to original subject
            return subject
        except Exception:
            return subject
    
    def _parse_nzb(self, nzb_content: str) -> List[NZBFile]:
        """Parse NZB content to extract files and segments"""
        try:
            # Manual XML parsing (more reliable than pynzb)
            root = ET.fromstring(nzb_content)
            files = []
            
            for file_elem in root.findall('.//{http://www.newzbin.com/DTD/2003/nzb}file'):
                subject = file_elem.get('subject', 'Unknown')
                
                groups = []
                for group_elem in file_elem.findall('.//{http://www.newzbin.com/DTD/2003/nzb}group'):
                    groups.append(group_elem.text)
                
                segments = []
                for seg_elem in file_elem.findall('.//{http://www.newzbin.com/DTD/2003/nzb}segment'):
                    segments.append({
                        'message_id': seg_elem.text,
                        'number': int(seg_elem.get('number', 0)),
                        'bytes': int(seg_elem.get('bytes', 0))
                    })
                
                nzb_file = NZBFile(
                    subject=subject,
                    groups=groups,
                    segments=segments,
                    total_bytes=sum(s['bytes'] for s in segments)
                )
                files.append(nzb_file)
            
            return files
            
        except Exception as e:
            logger.error(f"‚ùå Failed to parse NZB: {e}")
            return []
    
    def _download_segment(self, server: nntplib.NNTP, message_id: str, group: str) -> bytes:
        """Download a single segment"""
        try:
            # Select the newsgroup
            server.group(group)
            
            # Get the article
            resp, info = server.article(f"<{message_id}>")
            
            # Extract the body (skip headers)
            body_start = False
            body_lines = []
            for line in info:
                if body_start:
                    body_lines.append(line)
                elif line == b'':  # Empty line indicates end of headers
                    body_start = True
            
            # Join body lines
            raw_data = b'\r\n'.join(body_lines)
            
            # Try different yEnc decoders
            if HAS_YENC:
                try:
                    # Try sabyenc3 first
                    if hasattr(yenc, 'decode_string'):
                        decoded_data = yenc.decode_string(raw_data)[0]
                        return decoded_data
                    elif hasattr(yenc, 'decode'):
                        decoded_data = yenc.decode(raw_data)
                        return decoded_data
                    else:
                        logger.debug("‚ö†Ô∏è yEnc module found but no decode method available")
                        return self._manual_yenc_decode(raw_data)
                except Exception as e:
                    logger.debug(f"‚ö†Ô∏è yEnc decode failed, using manual method: {e}")
                    return self._manual_yenc_decode(raw_data)
            else:
                # Use manual yEnc decoding
                return self._manual_yenc_decode(raw_data)
                
        except Exception as e:
            logger.error(f"‚ùå Failed to download segment {message_id}: {e}")
            return b''
    
    def _manual_yenc_decode(self, data: bytes) -> bytes:
        """Basic manual yEnc decoding"""
        try:
            lines = data.split(b'\r\n')
            decoded_parts = []
            
            in_yenc_data = False
            for line in lines:
                if line.startswith(b'=ybegin'):
                    in_yenc_data = True
                    continue
                elif line.startswith(b'=yend'):
                    in_yenc_data = False
                    continue
                elif line.startswith(b'=ypart'):
                    continue
                elif not in_yenc_data:
                    continue
                
                # Basic yEnc decoding
                decoded_line = bytearray()
                i = 0
                while i < len(line):
                    byte = line[i]
                    if byte == ord('='):
                        # Escape sequence
                        if i + 1 < len(line):
                            next_byte = line[i + 1]
                            decoded_byte = (next_byte - 64 - 42) % 256
                            decoded_line.append(decoded_byte)
                            i += 2
                        else:
                            i += 1
                    else:
                        decoded_byte = (byte - 42) % 256
                        decoded_line.append(decoded_byte)
                        i += 1
                
                decoded_parts.append(bytes(decoded_line))
            
            return b''.join(decoded_parts)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Manual yEnc decode failed: {e}")
            return data
    
    def _download_nzb_real(self, download_id: str, nzb_files: List[NZBFile], download_path: str):
        """Download NZB files using real NNTP connection"""
        try:
            logger.info(f"üöÄ Starting real NZB download {download_id}")
            
            # Create download directory
            os.makedirs(download_path, exist_ok=True)
            
            total_bytes = sum(f.total_bytes for f in nzb_files)
            downloaded_bytes = 0
            
            for file_idx, nzb_file in enumerate(nzb_files):
                if download_id not in self.active_downloads:
                    logger.info(f"‚ùå Download {download_id} was cancelled")
                    return
                
                # Extract a clean filename from the subject
                clean_filename = self._extract_filename_from_subject(nzb_file.subject)
                logger.info(f"üìÅ Downloading file {file_idx + 1}/{len(nzb_files)}: {clean_filename}")
                
                # Create NNTP connection for this file
                try:
                    server = self._create_nntp_connection()
                except Exception as e:
                    logger.error(f"‚ùå Failed to connect for file {clean_filename}: {e}")
                    # Mark as failed and continue
                    if download_id in self.active_downloads:
                        self.active_downloads[download_id]["status"] = "failed"
                        try:
                            loop = asyncio.new_event_loop()
                            asyncio.set_event_loop(loop)
                            loop.run_until_complete(self._update_database_progress(download_id, 0.0, "failed"))
                            loop.close()
                        except Exception:
                            pass
                    return
                
                try:
                    # Create safe filename for the filesystem
                    safe_filename = "".join(c for c in clean_filename if c.isalnum() or c in (' ', '-', '_', '.', '(', ')'))
                    temp_file_path = os.path.join(download_path, f"temp_{download_id}_{file_idx}")
                    
                    segments_downloaded = 0
                    with open(temp_file_path, 'wb') as temp_file:
                        for seg_idx, segment in enumerate(nzb_file.segments):
                            if download_id not in self.active_downloads:
                                break
                                
                            logger.debug(f"‚¨áÔ∏è Downloading segment {seg_idx + 1}/{len(nzb_file.segments)}")
                            
                            # Try each group until one works
                            segment_data = b''
                            success = False
                            for group in nzb_file.groups:
                                try:
                                    segment_data = self._download_segment(server, segment['message_id'], group)
                                    if segment_data:
                                        success = True
                                        break
                                except Exception as e:
                                    logger.debug(f"Failed to download segment from group {group}: {e}")
                                    continue
                            
                            if success and segment_data:
                                temp_file.write(segment_data)
                                downloaded_bytes += len(segment_data)
                                segments_downloaded += 1
                                
                                # Update progress
                                progress = (downloaded_bytes / total_bytes) * 100 if total_bytes > 0 else 0
                                self.active_downloads[download_id]["progress"] = progress
                                
                                # Update progress in database periodically
                                if seg_idx % 10 == 0:  # Update every 10 segments
                                    try:
                                        loop = asyncio.new_event_loop()
                                        asyncio.set_event_loop(loop)
                                        loop.run_until_complete(self._update_database_progress(download_id, progress))
                                        loop.close()
                                    except Exception as e:
                                        logger.debug(f"Failed to update progress: {e}")
                                
                                if seg_idx % 50 == 0:  # Log every 50 segments
                                    logger.info(f"üìä NZB {download_id} progress: {progress:.1f}% ({segments_downloaded}/{len(nzb_file.segments)} segments)")
                            else:
                                logger.warning(f"‚ö†Ô∏è Failed to download segment {seg_idx + 1}")
                    
                    # Move temp file to final location with proper name
                    final_path = os.path.join(download_path, safe_filename)
                    
                    if os.path.exists(temp_file_path) and os.path.getsize(temp_file_path) > 0:
                        # Avoid filename conflicts
                        counter = 1
                        original_final_path = final_path
                        while os.path.exists(final_path):
                            name, ext = os.path.splitext(original_final_path)
                            final_path = f"{name}_{counter}{ext}"
                            counter += 1
                        
                        os.rename(temp_file_path, final_path)
                        logger.info(f"‚úÖ Created file: {final_path} ({segments_downloaded}/{len(nzb_file.segments)} segments)")
                    else:
                        logger.warning(f"‚ö†Ô∏è File {clean_filename} was empty or failed to download")
                        if os.path.exists(temp_file_path):
                            os.remove(temp_file_path)
                
                finally:
                    try:
                        server.quit()
                    except:
                        pass
            
            # Mark as completed
            if download_id in self.active_downloads:
                self.active_downloads[download_id]["status"] = "completed"
                self.active_downloads[download_id]["progress"] = 100.0
                logger.info(f"‚úÖ NZB download {download_id} completed!")
                
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    loop.run_until_complete(self._update_database_progress(download_id, 100.0, "completed"))
                    loop.close()
                except Exception as e:
                    logger.debug(f"Failed to update completion: {e}")
                
        except Exception as e:
            logger.error(f"‚ùå Error in real NZB download {download_id}: {e}")
            if download_id in self.active_downloads:
                self.active_downloads[download_id]["status"] = "failed"
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    loop.run_until_complete(self._update_database_progress(download_id, 0.0, "failed"))
                    loop.close()
                except Exception as e:
                    logger.debug(f"Failed to update error: {e}")
    
    def _download_nzb_mock(self, download_id: str, download_path: str, nzb_name: str = None):
        """Mock NZB download for testing"""
        try:
            logger.info(f"üé≠ Starting mock NZB download {download_id}")
            
            # Simulate download progress
            for progress in range(0, 101, 5):
                if download_id not in self.active_downloads:
                    break
                    
                time.sleep(0.5)  # Simulate download time
                self.active_downloads[download_id]["progress"] = float(progress)
                
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    loop.run_until_complete(self._update_database_progress(download_id, float(progress)))
                    loop.close()
                except Exception as e:
                    logger.debug(f"Failed to update mock progress: {e}")
                
                if progress % 20 == 0:
                    logger.info(f"üìä NZB {download_id} progress: {progress:.1f}%")
            
            # Mark as completed and create mock files
            if download_id in self.active_downloads:
                self.active_downloads[download_id]["status"] = "completed"
                self.active_downloads[download_id]["progress"] = 100.0
                logger.info(f"‚úÖ NZB download {download_id} completed!")
                
                # Create realistic mock downloaded files
                os.makedirs(download_path, exist_ok=True)
                
                # Use the NZB name if available
                base_name = nzb_name or f"Sample.Media.{download_id}"
                
                mock_files = [
                    f"{base_name}.mkv",
                    f"{base_name}.nfo",
                    f"{base_name}.sfv"
                ]
                
                created_files = []
                for filename in mock_files:
                    mock_file_path = os.path.join(download_path, filename)
                    try:
                        with open(mock_file_path, "w") as f:
                            if filename.endswith(".mkv"):
                                # Create a small file to simulate video
                                f.write("Mock video file content\n" * 1000)
                            elif filename.endswith(".nfo"):
                                f.write(f"Mock NFO file for {base_name}\nGenerated at {datetime.now()}\n")
                            else:
                                f.write(f"Mock file for {base_name}\nCreated at {datetime.now()}\n")
                        created_files.append(mock_file_path)
                        logger.info(f"üìÅ Created mock file: {mock_file_path}")
                    except Exception as e:
                        logger.error(f"‚ùå Failed to create mock file {mock_file_path}: {e}")
                
                logger.info(f"üé¨ Created {len(created_files)} mock files for download {download_id}")
                
                try:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    loop.run_until_complete(self._update_database_progress(download_id, 100.0, "completed"))
                    loop.close()
                except Exception as e:
                    logger.debug(f"Failed to update completion: {e}")
                
        except Exception as e:
            logger.error(f"‚ùå Error in mock download progress for {download_id}: {e}")
            if download_id in self.active_downloads:
                self.active_downloads[download_id]["status"] = "failed"
    
    async def add_nzb_download(self, nzb_content: str, download_id: str, download_path: str, filename: str = None) -> bool:
        """Add an NZB download"""
        try:
            logger.info(f"üöÄ Starting NZB download {download_id} (Real mode: {not self.mock_mode})")
            
            # Parse NZB content to get name
            nzb_name = filename
            if not nzb_name:
                # Try to extract name from NZB content
                nzb_files = self._parse_nzb(nzb_content)
                if nzb_files:
                    nzb_name = self._extract_filename_from_subject(nzb_files[0].subject)
            
            if not self.mock_mode:
                # Parse NZB content for real download
                nzb_files = self._parse_nzb(nzb_content)
                if not nzb_files:
                    logger.error(f"‚ùå No files found in NZB for download {download_id}")
                    return False
                
                logger.info(f"üìã Found {len(nzb_files)} files in NZB")
                
                # Add to active downloads
                self.active_downloads[download_id] = {
                    "status": "downloading",
                    "progress": 0.0,
                    "download_path": download_path,
                    "files": nzb_files,
                    "start_time": datetime.now(),
                }
                
                # Start real download in background thread
                download_thread = threading.Thread(
                    target=self._download_nzb_real,
                    args=(download_id, nzb_files, download_path)
                )
            else:
                # Add to active downloads for mock
                self.active_downloads[download_id] = {
                    "status": "downloading",
                    "progress": 0.0,
                    "download_path": download_path,
                    "start_time": datetime.now(),
                }
                
                # Start mock download in background thread
                download_thread = threading.Thread(
                    target=self._download_nzb_mock,
                    args=(download_id, download_path, nzb_name)
                )
            
            self.download_threads[download_id] = download_thread
            download_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error starting NZB download {download_id}: {e}")
            return False
    
    async def pause_download(self, download_id: str) -> bool:
        """Pause an NZB download"""
        if download_id in self.active_downloads:
            self.active_downloads[download_id]["status"] = "paused"
            logger.info(f"‚è∏Ô∏è Paused download {download_id}")
            return True
        return False
    
    async def resume_download(self, download_id: str) -> bool:
        """Resume an NZB download"""
        if download_id in self.active_downloads:
            self.active_downloads[download_id]["status"] = "downloading"
            logger.info(f"‚ñ∂Ô∏è Resumed download {download_id}")
            return True
        return False
    
    async def cancel_download(self, download_id: str) -> bool:
        """Cancel an NZB download"""
        if download_id in self.active_downloads:
            del self.active_downloads[download_id]
            if download_id in self.download_threads:
                # Note: Thread will check for download_id existence and exit
                del self.download_threads[download_id]
            logger.info(f"‚ùå Cancelled download {download_id}")
            return True
        return False
    
    async def get_download_status(self, download_id: str) -> Optional[Dict]:
        """Get status of an NZB download"""
        if download_id not in self.active_downloads:
            return None
            
        download_info = self.active_downloads[download_id]
        return {
            "status": download_info["status"],
            "progress": download_info["progress"],
            "speed": download_info.get("speed", 0),
            "files_count": len(download_info.get("files", [])),
            "start_time": download_info.get("start_time"),
        }
    
    def get_global_stats(self) -> Dict:
        """Get global download statistics"""
        total_downloads = len(self.active_downloads)
        active_downloads = len([d for d in self.active_downloads.values() if d["status"] == "downloading"])
        paused_downloads = len([d for d in self.active_downloads.values() if d["status"] == "paused"])
        completed_downloads = len([d for d in self.active_downloads.values() if d["status"] == "completed"])
        
        return {
            "total_downloads": total_downloads,
            "active_downloads": active_downloads,
            "paused_downloads": paused_downloads,
            "completed_downloads": completed_downloads,
            "server": self.server,
            "mock_mode": self.mock_mode
        }

    async def _update_database_progress(self, download_id: str, progress: float, status: str = None):
        """Update the database with current progress"""
        try:
            # Import here to avoid circular imports
            from ..services_manager import services
            download_service = services.get_download_service()
            
            # Get the download
            download = await download_service.get_download(int(download_id))
            if download:
                download.progress = progress
                if status:
                    from ..models.download import DownloadStatus
                    if status == "completed":
                        download.status = DownloadStatus.COMPLETED
                    elif status == "downloading":
                        download.status = DownloadStatus.DOWNLOADING
                    elif status == "failed":
                        download.status = DownloadStatus.FAILED
                
                await download_service.update_download(download)
                logger.debug(f"üíæ Updated database: Download {download_id} - {progress:.1f}% - {status or 'downloading'}")
        except Exception as e:
            logger.error(f"‚ùå Error updating database for download {download_id}: {e}")
